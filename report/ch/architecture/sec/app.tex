\subsection{Android app architecture}
The app runs on the users' Android device and was designed to run on Android version 4.0 or greater. As of March 2014 this makes up for 79,7\% of Android devices~\cite{AndroidDeviceFragmentation}. 
The team decided to only adapt the app for these versions because the app is a proof-of-concept, and for the purposes of the app, the team assumed that the relevant users would have a relatively modern phone. 

\subsubsection{Best practice}

The best practice guidelines for Android~\cite{androidPracticePerformance} states that one should keep the architecture as simple as possible. 
Avoid using large and complex design patterns. But concise code guidelines, and use of tools are needed to keep the development process as simple and effective as possible. 

The app will use a lot of data from a SQlite database, the UI must be responsive, and data will be synchronized from the Internet. To make the app work fluently a good architecture is needed. It is important to note that Android renders the UI on the main thread. Running long operations on the main thread will block the entire app interface. That must be avoided at all cost to not destroy the user experience. 
To avoid the issue of blocking the main thread it was decided to make use of Androids built in logic for async data access, and a design pattern for business logic.

\subsubsection{Class logic}

\todo{An Activity is the main 'thing` in Android. It's a process with a full life-cycle and the possibility to show a view. }

The different parts of the app is accessed through a navigation drawer~\ref{fig:class_diagram_drawer}. The navigation drawer is a Fragment, a self contained view with a life-cycle that resides in a Activity. By using fragments will the code be modularized in self contained environments. When a tab in the navigation drawer is chosen it will use a callback to the activity which changes the view to the correct fragment class. 

\begin{figure}[H]
\includegraphics[width=\textwidth]{ch/architecture/fig/class_diagram_drawer.png}
\caption{Class diagram for the main Activity.}
\label{fig:class_diagram_drawer}
\end{figure}

Each tab has it's own logic and has a default behavior defined by 'DefaultTabFragment`~\ref{fig:class_diagram_fragments}

\begin{figure}[H]
\includegraphics[width=\textwidth]{ch/architecture/fig/class_diagram_fragments.png}
\caption{Class diagram for the fragments.}
\label{fig:class_diagram_fragments}
\end{figure}

\subsubsection{Data access}

Data access to the underlying database is done using ContentProviders~\cite{contentproviders}. This gives the app a uniform \gls{CRUD} access model. The data will be accessed with \gls{URI}'s that is uniquely defined. Fetching the data is done using LoaderManager~\cite{loadermanager} . LoaderManager is an interface defining callbacks to get the URI to query, how to handle data reset, and the data returned from the query. The LoaderManager runs on another thread, and thus avoids the problem of halting the UI rendering. It will also handle the life cycle of the data. When data related to the URI changes the LoaderManager will load the data again. 

ContentProviders contains a lot of boilerplate code and is time consuming to code. But the upsides far outweigh the downsides. When ContentProviders are used with LoaderManager one gets a view that is automatically updated when the data changes without bothering the UI thread. Other solutions are to work directly on the SQLite driver with SQL, or use patters to make it work fluently. But when the choice is between a native building block and a complex pattern the choice is easy to make. 

\subsubsection{Business logic}

\todo{What was the first problem? Why is this a problem?}The other problem is related to where to place the business logic for data manipulation. The business logic must be kept in a logic place and not spread around in the view code. That can create hard to find bugs and make it difficult to change how the logic works.
The group decided to use the pattern Model-View-Presenter (MVP). MVP is a Model-View-Controller (MVC) derivative~\cite{mvc}. All business logic is handled in presenter classes, between the views and models. Through this uniform access, all logic applied to data preservation (sever synchronization), and data control can be handled in one place. The life cycle of the presenter classes is in the base Activity class, and all other sub fragments can get access to it though a interface. 
This pushes almost all logic into the presenters, making the code in the fragments as minimal as possible. Since all data is accessed through a ContentProvider it was possible to only adopt this pattern. No view updating code is needed. Only how to manipulate the models and apply it back to the ContentProvider.

\todo{Diagram showing M <-> V <-> P}

\subsubsection{User authentication}

The user authentication is made to be token based. For the moment this is not entirely true to how it is done now. Some shortcuts were done to have a working system. But the main authentication architecture is made.

The Android system has it's own account architecture. Working with this architechture requires the app to register a AbstractAccountAuthenticator~\cite{androidAccount} class in the AndroidManifest. The AbstractAccountAuthenticator is generic and can be made to create accounts for all types of services. Our system uses OAuthV2.0 where the third party authenicator is facebook. The token returned from Facebook is stored in the account and accessed when necessary. All other data related to the account is also stored (facebook user id, etc).

Other OAuthV2.0 authentication providers can also be used (Twitter, Google, your own private OAuthV2.0 authenticator, etc). 

For the time being only the Facebook user id is used to authenticate the user to our server.

\subsubsection{Server data access}

All data is saved on the server. Communication to server is done with a framework named Volley. It is created by Google and the source code resides within AOSP (Android Open Source Project). It is made to make communication with REST endpoints easier.

Most of all server access is done when synchronizing data with the server~\ref{fig:architecture}. 
Data synchronization is done by using Androids built in SyncAdapter. The SyncAdapter is a self-contained process that that fetches and delivers all new data to and from the server. The SyncAdapter is registered to a specific account on the Android system. The account will then provide the session data that will identify the user to the server.
Communication to the database is done through a ContentProvider. Updating the view is then done automatically when the app is running. 

The algorithm for how the data synchronization is done is showed as pesudocode in figure~\ref{fig:algorithm_sync}

%Pseudo code for the sync
\begin{figure}[H]
\begin{lstlisting}[]
var lastSync = Last synchronization time stamp from account
var now = Current time in unix epoch

var localDataModels = Get all local changes after lastSync

var serverDataModels = Get all server changes after lastSync

sendLocalModelsToServer(localDataModels)

saveModelsToLocalDB(serverDataModels)

if no errors
  accountLastSync = now
\end{lstlisting}
\caption{Algorithm for the synchronization flow.}
\label{fig:algorithm_sync}
\end{figure}

SyncAdapters can be configured to run when it is suited; It has been a while since last synchronization, there is Internet connection through wifi and the processor is not busy.

\subsubsection{Keeping the code clean}

Android has a tool named StrictMode~\cite{androidStrictMode}. It can be tweaked to monitors the UI thread and check for file operations, network access and other problems. The penalty for breaking these defined rules can be set to emit a stack trace or kill the app. By having StrictMode configured while coding made discovering bad design easy to detect. 

The app will follow standard Android design guidelines regarding the user interface design.

\todo{class diagram front-end}

\begin{figure}[H]
\includegraphics[width=\textwidth]{ch/architecture/fig/arch.png}
\caption{Architecture overview of app communication with the server.}
\label{fig:architecture}
\end{figure}
