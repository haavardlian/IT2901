\section{Android app architecture}
\label{sec:arch_app}
The app is developed to run on Android versions 4.0 or greater. As of March 2014 this makes up for 79,7\% of all Android devices in use~\cite{AndroidDeviceFragmentation}.
Support for earlier versions would require extra work, and because the app is a proof-of-concept this was not considered a problem.


\subsection{Best practice}
The best practice guidelines for Android~\cite{androidPracticePerformance} state that one should avoid using a complex architecture. A complex architecture will increase the code base and is overkill in most situations. A structured pattern with concise code guidelines is needed to keep the development process as simple, effective, and bug free as possible. The next sections will explain how the app is initialized, and the code structure that allows a flow through the different functionality of the app. The subsequent sections after that go into detail about threading, data access, and synchronization.

\subsection{Overall structure}
The Activity is the starting point of the app. It can also be explained as the main ''thing'' in Android. It is a self contained process with the full life-cycle of the device and the possibility to show a view to the user.

To access the different parts of the app it was decided to use a navigation drawer that is accessed through the app icon on the action bar, or with a swipe from the left. The different sections of the app are shown when the user clicks on it in the navigation drawer. Each section accessed through the navigation drawer is henceforth called a tab. The structure of how the main activity communicates with the navigation drawer is shown in figure~\ref{fig:classDiagramDrawer}.

The navigation drawer and all of the tabs are implemented as Fragments. A Fragment is a representation of some behavior or an interface. It is embedded inside an Activity and can be swapped in and out of the Activity. Multiple Fragments can live in the same view. A subset of the Activity life-cycle is implemented in Fragments so it can work as a self contained module. 

\begin{figure}[H]
\includegraphics[width=\textwidth]{ch/architecture/fig/class_diagram_drawer.png}
\caption{Class diagram for the main Activity.}
\label{fig:classDiagramDrawer}
\end{figure}

When a tab in the navigation drawer is chosen it will use a callback to the 'DrawerActivity` class which swaps in the new Fragment to the view and closes the navigation drawer.

Each tab has its own logic and has a default behavior defined by 'DefaultTabFragment`. A class diagram illustrating the main Fragments is shown in figure~\ref{fig:classDiagramFragments}. The default behavior takes care of updating the name of the current tab to the Action Bar.

\begin{figure}[H]
\includegraphics[width=\textwidth]{ch/architecture/fig/class_diagram_fragments.png}
\caption{Class diagram for the fragments.}
\label{fig:classDiagramFragments}
\end{figure}

\subsection{Android rendering and the main thread}
One of the key issues on mobile app development (besides good interface design) is keeping the \gls{UI} responsive. Having a UI that lags, or makes the rest of the interface unresponsive when a command has been issued, will most often upset the user and result in the app being uninstalled from the device.

Android renders the UI on the main thread. Running long operations on the main thread will make the entire interface unresponsive. As stated, that must be avoided at all cost to not destroy the user experience. 

The functionality of the app uses a lot of data stored in the local SQLite database. The data will also be synchronized to the server with a authenticated user. All these types of operations take time and blocks the thread it is running on.

The choice of how to handle this will make a large impact on the overall performance of the app. The next sections will explain how the different parts of the app work together as a process, how data is accessed and used, what patterns are used, how a user is authenticated, and data backup.

%To avoid the issue of blocking the main thread it was decided to make use of Androids built in logic for async data access, and a design pattern for business logic.

\subsection{Data access}
Data access to the underlying database is done using ContentProviders~\cite{contentproviders}. This gives the app a uniform \gls{CRUD} (acronym for create, read, update, and delete) access model. The data will be accessed with \gls{URI}'s (acronym for uniform resource identifier) that are uniquely defined. An overview of how the data layer is implemented is shown in figure~\ref{fig:archAppOverview}.

The boxes in the figure represent the different Fragments that use data in the app. Fetching data to the Fragment is done by through the LoaderManager~\cite{loadermanager} interface. \todo{LoaderManager defines a callback to retrieve the URI to query, how to handle data reset, and the data returned from the query}. The LoaderManager runs on a separate thread, and thus avoids the problem of blocking the main thread from rendering the UI. It will also handle the life cycle of the data. When data related to the URI changes, the LoaderManager will load the data again. 

\begin{figure}[H]
\includegraphics[width=\textwidth]{ch/architecture/fig/arch_app_overview.png}
\caption{Overview of how data is accessed.}
\label{fig:archAppOverview}
\end{figure}

ContentProviders contain a lot of boilerplate code and are time consuming to code. However, the upsides to using ContentProvider far outweigh the downsides. When ContentProviders are used with LoaderManager, the result is a view that is automatically updated when the data changes without bothering the UI thread. \todo{Other solutions are to work directly on the SQLite driver with SQL, or use a pattern to make it work fluently. One such pattern is discussed in the next section. }

\subsection{Business logic}
After defining a uniform access model to the database, the issue of where to place the actual business logic (data manipulation) must be tackled. Keeping the business logic in one place makes changing data a lot easier, and avoids the issue of keeping track of every data operation so it is possible to handle updating of views. By centralizing all the business logic you also allow for easier location of bugs in the code.\todo{ Following a smart design pattern will handle your business logic and make it easy to update the view. }

The team decided to use the pattern Model-View-Presenter (MVP). MVP is a Model-View-Controller (MVC) derivative~\cite{mvc}. All business logic is handled in presenter classes, between the views and models. Through this uniform access, all logic applied to data preservation (server synchronization), and data control can be handled in one place. The structure of presenters can be seen in figure~\ref{fig:archAppOverview}

The life cycle of the presenter classes is located in the base Activity class, and all other sub fragments can get access to it though an interface. 
This pushes almost all logic into the presenters, making the code in the fragments as minimal as possible. 

By using the full MVP pattern, the view is easy to update when data changes. In our case that was not needed since all data is accessed through a ContentProvider. The Presenters only handle the manipulation of the models and commits the changes to the database. The current implementation can easily be extended to use the complete pattern if it is needed in another iteration of the app.  

\begin{figure}[H]
\includegraphics[width=\textwidth]{ch/architecture/fig/mvp.png}
\caption{MVP}
\label{fig:mvp}
\end{figure}

\subsection{User authentication}
The app is designed with the ability to synchronize data to the server. Our server, as explained in section~\ref{sec:arch_server}, exposes a restful API were data can be backed up.

The first challenge that arises with data synchronization is that the user must be identified as a unique and authorized user. \todo{The choice was made not to make our own authenticator. By using a third party authenticator to handle user and user id with OAuthV2.0~\cite{oauthv2.0} we made the device authentication token based.}
For the time being the third party authenticator is Facebook and session data is maintained with the FacebookSDK for Android. 
%For the moment this is not entirely true to how it is done now. Some shortcuts were done to have a working system. But the main authentication architecture is made.
A user can log in with his Facebook user and fetch data connected to his account.\todo{ The next issue is how to communicate with our server. }

The next case is how to handle the session data from Facebook. The Android system has its own account architecture. Working with this architecture requires the app to register a AbstractAccountAuthenticator~\cite{androidAccount} class in the AndroidManifest. The AbstractAccountAuthenticator is generic and can be made to create accounts for all types of services. The token and other related data (Facebook id) returned from Facebook is stored in the account and can accessed when necessary.

Other OAuthV2.0 authentication providers can also be used (Twitter, Google, your own private OAuthV2.0 authenticator, etc). 

%For the time being only the Facebook user id is used to authenticate the user to our server.

\subsection{Server data access}
All the user data is saved on the server. Communication with the server is done with the framework ''Volley''. It is created by Google and the source code resides within AOSP (Android Open Source Project). It is made to make communication with restful endpoints easier.

Data synchronization is done by using Androids built in SyncAdapter. The SyncAdapter is a self-contained process that that fetches and delivers all new data to and from the server. The SyncAdapter is registered to a specific account on the Android system. The account will then provide the session data that will identify the user to the server. How the session data was acquired was explained in the previous section. For the time being only the Facebook id is used when communicating with the server. This is not secure in any way. But changing this to use the token and make the server find the user id based on the token is an relatively easy improvement to implement. \todo{burde ikke dette være skrevet i further development?}

Communication with the database is still done through a ContentProvider. Since the changes will affect the URI, the view will get the new data and be rendered again automatically if the the app is running. This can be seen in figure~\ref{fig:archAppOverview}.\todo{hva menes her?}

The algorithm for how data synchronization is done is showed as pseudo code in code snippet~\ref{fig:algorithm_sync}.

%Pseudo code for the sync

\noindent\begin{minipage}{\textwidth}
\begin{lstlisting}[caption={Algorithm for the synchronization flow.}, label={fig:algorithm_sync}]
var lastSync = Last synchronization time stamp from account
var now = Current time in Unix epoch

var localDataModels = Get all local changes after lastSync

var serverDataModels = Get all server changes after lastSync

sendLocalModelsToServer(localDataModels)

saveModelsToLocalDB(serverDataModels)

if no errors
  accountLastSync = now
\end{lstlisting}
\end{minipage}

The algorithm is straightforward and will retry data synchronization until it succeeds. The reason for this is that the synchronization timestamp will only be updated when everything goes well. If the error checking fails and the last synchronization timestamp fails, then data will be lost. This is not a perfect approach to synchronization, \todo{what? ->}but acceptable within the time frame that it was needed. 

SyncAdapters can be configured to run when Android feels it has time for running them. This is when the processor is not busy and WiFi Internet connection is available. It can also be forced to run on regular intervals.

\subsection{Keeping the code clean}
Other long running operations, for example the rendering of the graph, will block the main thread if it is not implemented correctly. To avoid the main thread to be blocked in those cases, AsyncTask is used. AsyncTask defines an interface to give references to objects, an operation to run on another thread, and code to run after the long operation is finished that can update the UI. 

\todo{Thereafter code written must generally continue to avoid doing wrong operations on the main thread. Forgetting to do this properly is easy. fix please, skjønner lite} To enforce the proper use of this threading, Android has a tool named StrictMode~\cite{androidStrictMode}. It can be tweaked to monitor the UI thread and check for file operations, network access and other problems. The penalty for breaking these defined rules can be set to emit a stack trace or kill the app. Having StrictMode configured while coding makes discovering bad implementation choices easier. 

%The app will follow standard Android design guidelines regarding the user interface design.
