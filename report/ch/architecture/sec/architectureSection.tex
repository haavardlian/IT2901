\section{Architecture}
In order to provide users with all the requested functionality, the team was in need of something more than an Android app. We also needed a back-end in order to provide statistical data and to collect data from the user's home.

The implementation consists of three parts. The server, the device in the users home used to collect and send usage data, and the Android app.

\subsection{Server}
The server consists of two parts. One for handling requests from the Android app and one for storing data that is collected in the users home. 
The part that handles the Android app runs Dropwizard, which is a collection of Java libraries that together constitutes a REST service. 

These libraries include Jetty, Jersey, JDBC, and Jackson. These are discussed in further detail in section~\ref{sec:libraries}. The server exposes a set of URLs that provided the Android app with the ability to retrieve and store data from the database. The part of the system that would aggregate collected data from a aggregation server in the users home is not implemented. More on this in modularity~\ref{sec:modularity} and the further developement chapter~\ref{sec:further}.

\subsection{Android Application}
\todo{a lot of these formulations are missing some words and are a bit weird. plz fix}
The app runs on the users' Android device and was designed to run on Android version 4.0 or greater. As of March 2014 this makes up for 79,7\% of Android devices~\cite{AndroidDeviceFragmentation}. The team decided to only adapt the app for these versions because the app is a proof-of-concept, and for the purposes of the app, the team assumed that the relevant users would have a relatively modern phone. 

The architecture heavily relied on using ContentProviders~\cite{contentproviders} for database access. This gives the app a uniform access model for the data that does not run on the UI thread. When lists of data are accessed from an Activity or a Fragment, the LoaderManagers~\cite{loadermanager} is used. This handles the life cycle of data change notification through the cursor. 

The remaining problem was where to place the business logic for data manipulation. This is where the pattern Model-View-Presenter (MVP) comes in. MVP is a Model-View-Controller (MVC) derivative.~\cite{mvc} All business logic is handled in presenter classes. Through this uniform access, all logic applied to data preservation (sever synchronization), and data control can be handled in one place. The life cycle of the presenter classes is in the base Activity class, and all other sub fragments can get access to it though a interface. This pushes almost all logic into the presenters, making the code in the fragments as minimal as possible.

The app will follow standard Android design guidelines regarding the user interface design.

\subsection{Home Data Aggregator}
This device collects data from sources in the user's home. The reason why we chose this external box as opposed to using the user's phone to collect data, was that with this solution, the system could fetch data at regular intervals throughout the whole day. This would result in that the user would not need to be home in order for the app to collect 
usage data. The device would pass data along to the external server at request from the server.

\begin{figure}[H]
\includegraphics[width=\textwidth]{ch/architecture/fig/architecture.png}
\caption{Architecture overview}
\end{figure}
